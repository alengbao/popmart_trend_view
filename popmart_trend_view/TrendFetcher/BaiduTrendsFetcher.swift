import Foundation

class BaiduTrendsFetcher: TrendFetcher {
    let source = "ÁôæÂ∫¶ÊåáÊï∞"
    var lastFetchDate: Date?
    var mocker: TrendMocker
    let isMock = false
    let zoom = 1000

    // ÈÖçÁΩÆÂèÇÊï∞ - Áõ¥Êé•Âú®‰ª£Á†Å‰∏≠ËÆæÁΩÆ
    private let keyword = "Ê≥°Ê≥°ÁéõÁâπ"  // ÊêúÁ¥¢ÂÖ≥ÈîÆËØç
    private let cookieFile = "baidu_cookie.txt"  // CookieÊñá‰ª∂
    
    init() {
        self.mocker = TrendMocker(source: source,
                                  data: [55, 57, 61, 65, 64, 62, 60, 58, 56, 54, 52, 50, 48, 46, 44, 42, 40, 38, 36, 34, 32, 30, 28, 26, 24, 22],
                                  index: 7)
    }
    
    func fetch() async -> [TrendData] {
        // Â¶ÇÊûú‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆÔºåÁõ¥Êé•ËøîÂõû
        if isMock {
            print("üé≠ ‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆ")
            return mocker.Mock()
        }
        
        // ÊåâÈ°∫Â∫èÊâßË°åÁà¨ÂèñÊµÅÁ®ã
        let trendData = await crawlBaiduIndex()
        
        // ËøáÊª§Êï∞ÊçÆÔºöÂè™‰øùÁïô‰∏äÊ¨°Ëé∑ÂèñÊó•Êúü‰πãÂêéÁöÑÊï∞ÊçÆ
        let filteredData: [TrendData]
        if let lastDate = lastFetchDate {
            filteredData = trendData.filter { $0.date > lastDate }
        } else {
            filteredData = trendData
        }
        
        // Êõ¥Êñ∞ÊúÄÂêéËé∑ÂèñÊó•ÊúüÔºö‰ΩøÁî®ÂéüÂßãÊï∞ÊçÆÁöÑÊúÄÊñ∞Êó•ÊúüÔºåËÄå‰∏çÊòØËøáÊª§ÂêéÁöÑÊï∞ÊçÆ
        if let latestDate = trendData.last?.date {
            lastFetchDate = latestDate
        }
        
        return filteredData
    }
    
    // ‰∏ªÁà¨ÂèñÊµÅÁ®ã
    private func crawlBaiduIndex() async -> [TrendData] {
        print("üöÄ ÂºÄÂßãÁôæÂ∫¶ÊåáÊï∞Áà¨ÂèñÊµÅÁ®ã...")
        
        // 1. Ëé∑ÂèñCookie
        guard let cookie = getCookie() else {
            print("‚ùå CookieËé∑ÂèñÂ§±Ë¥•")
            return []
        }
        print("‚úÖ CookieËé∑ÂèñÊàêÂäüÔºåÈïøÂ∫¶: \(cookie.count)")
        
        // 2. Ëé∑ÂèñÊï∞ÊçÆ
        guard let responseData = await fetchData(cookie: cookie) else {
            print("‚ùå Êï∞ÊçÆËé∑ÂèñÂ§±Ë¥•")
            return []
        }
        print("‚úÖ Êï∞ÊçÆËé∑ÂèñÊàêÂäüÔºåÈïøÂ∫¶: \(responseData.count)")
        
        // 3. Ëß£ÊûêJSON
        guard let json = parseJSON(data: responseData) else {
            print("‚ùå JSONËß£ÊûêÂ§±Ë¥•")
            return []
        }
        print("‚úÖ JSONËß£ÊûêÊàêÂäü")
        
        // 4. Ëé∑ÂèñuniqidÂπ∂Ëé∑ÂèñÂ≠óÂÖ∏
        guard let uniqid = getUniqid(from: json) else {
            print("‚ùå Êó†Ê≥ïËé∑Âèñuniqid")
            return []
        }
        print("‚úÖ Ëé∑ÂèñÂà∞uniqid: \(uniqid)")
        
        guard let ptbk = await getDecryptionDictionary(uniqid: uniqid, cookie: cookie) else {
            print("‚ùå Êó†Ê≥ïËé∑ÂèñËß£ÂØÜÂ≠óÂÖ∏")
            return []
        }
        print("‚úÖ Ëé∑ÂèñÂà∞Ëß£ÂØÜÂ≠óÂÖ∏ÔºåÈïøÂ∫¶: \(ptbk.count)")
        
        // 5. Ëß£ÊûêÂØÜÊñá
        let trendData = decryptData(ptbk: ptbk, json: json)
        print("‚úÖ ÂØÜÊñáËß£ÊûêÂÆåÊàêÔºåÂÖ±Ëß£Êûê \(trendData.count) ‰∏™Êï∞ÊçÆÁÇπ")
        
        return trendData
    }
    
    // 1. Ëé∑ÂèñCookie
    private func getCookie() -> String? {
        print("üîç Ëé∑ÂèñCookie...")
        
        // Ëé∑ÂèñÂΩìÂâçÊñá‰ª∂ÊâÄÂú®ÁõÆÂΩï
        let currentFileURL = URL(fileURLWithPath: #file)
        let currentDirectory = currentFileURL.deletingLastPathComponent()
        let cookieFileURL = currentDirectory.appendingPathComponent(cookieFile)
        
        print("üìÅ CookieÊñá‰ª∂Ë∑ØÂæÑ: \(cookieFileURL.path)")
        
        do {
            let cookie = try String(contentsOf: cookieFileURL, encoding: .utf8)
            if !cookie.isEmpty {
                return cookie
            } else {
                print("‚ùå CookieÊñá‰ª∂‰∏∫Á©∫")
                return nil
            }
        } catch {
            print("‚ùå Êó†Ê≥ïËØªÂèñCookieÊñá‰ª∂: \(error)")
            print("üí° ËØ∑Á°Æ‰øùCookieÊñá‰ª∂Â≠òÂú®‰∫é: \(cookieFileURL.path)")
            return nil
        }
    }
    
    // 2. Ëé∑ÂèñÊï∞ÊçÆ
    private func fetchData(cookie: String) async -> Data? {
        print("üì° Ëé∑ÂèñÁôæÂ∫¶ÊåáÊï∞Êï∞ÊçÆ...")
        
        // ÊûÑÂª∫ËØ∑Ê±ÇÂèÇÊï∞
        let words = [[["name": keyword, "wordType": 1]]]
        let wordsJson = try? JSONSerialization.data(withJSONObject: words)
        let wordsString = String(data: wordsJson ?? Data(), encoding: .utf8) ?? "[]"
        
        let urlString = "https://index.baidu.com/api/SearchApi/index?area=0&word=\(wordsString)&days=30"
        
        guard let url = URL(string: urlString) else {
            print("‚ùå Êó†ÊïàÁöÑURL")
            return nil
        }
        
        var request = URLRequest(url: url)
        
        // ËÆæÁΩÆËØ∑Ê±ÇÂ§¥
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("application/json, text/plain, */*", forHTTPHeaderField: "Accept")
        request.setValue("Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36", forHTTPHeaderField: "User-Agent")
        request.setValue("same-origin", forHTTPHeaderField: "Sec-Fetch-Site")
        request.setValue("cors", forHTTPHeaderField: "Sec-Fetch-Mode")
        request.setValue("empty", forHTTPHeaderField: "Sec-Fetch-Dest")
        request.setValue("1698156005330_1698238860769_ZPrC2QTaXriysBT+5sgXcnbTX3/lW65av4zgu9uR1usPy82bArEg4m9deebXm7/O5g6QWhRxEd9/r/hqHad2WnVFVVWybHPFg3YZUUCKMTIYFeSUIn23C6HdTT1SI8mxsG5mhO4X9nnD6NGI8hF8L5/G+a5cxq+b21PADOpt/XB5eu/pWxNdwfa12krVNuYI1E8uHQ7TFIYjCzLX9MoJzPU6prjkgJtbi3v0X7WGKDJw9hwnd5Op4muW0vWKMuo7pbxUNfEW8wPRmSQjIgW0z5p7GjNpsg98rc3FtHpuhG5JFU0kZ6tHgU8+j6ekZW7+JljdyHUMwEoBOh131bGl+oIHR8vw8Ijtg8UXr0xZqcZbMEagEBzWiiKkEAfibCui59hltAgW5LG8IOtBDqp8RJkbK+IL5GcFkNaXaZfNMpI=", forHTTPHeaderField: "Cipher-Text")
        request.setValue("https://index.baidu.com/v2/main/index.html", forHTTPHeaderField: "Referer")
        request.setValue("zh-CN,zh;q=0.9", forHTTPHeaderField: "Accept-Language")
        request.setValue(cookie, forHTTPHeaderField: "Cookie")
        
        do {
            print("üì° ËØ∑Ê±ÇURL: \(urlString)")
            
            let (data, response) = try await URLSession.shared.data(for: request)
            
            if let httpResponse = response as? HTTPURLResponse {
                print("üì° HTTPÁä∂ÊÄÅÁ†Å: \(httpResponse.statusCode)")
                
                if httpResponse.statusCode != 200 {
                    print("‚ùå ËØ∑Ê±ÇÂ§±Ë¥•ÔºåÁä∂ÊÄÅÁ†Å: \(httpResponse.statusCode)")
                    return nil
                }
            }
            
            let responseString = String(data: data, encoding: .utf8) ?? ""
            print("üìÑ ÂìçÂ∫îÊï∞ÊçÆÈïøÂ∫¶: \(responseString.count) Â≠óÁ¨¶")
            print("üìÑ ÂìçÂ∫îÂÜÖÂÆπÈ¢ÑËßà: \(responseString)")
            
            return data
            
        } catch {
            print("‚ùå ÁΩëÁªúËØ∑Ê±ÇÂ§±Ë¥•: \(error)")
            return nil
        }
    }
    
    // 3. Ëß£ÊûêJSON
    private func parseJSON(data: Data) -> [String: Any]? {
        print("üîç Ëß£ÊûêJSON...")
        
        do {
            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            
            if let json = json {
                // Ê£ÄÊü•Áä∂ÊÄÅ
                if let status = json["status"] as? Int, status != 0 {
                    print("‚ùå APIËøîÂõûÈîôËØØÁä∂ÊÄÅ: \(status)")
                    if let message = json["message"] as? String {
                        print("ÈîôËØØ‰ø°ÊÅØ: \(message)")
                    }
                    return nil
                }
                
                return json
            } else {
                print("‚ùå Êó†Ê≥ïËß£Êûê‰∏∫JSON")
                return nil
            }
        } catch {
            print("‚ùå JSONËß£ÊûêÈîôËØØ: \(error)")
            return nil
        }
    }
    
    // 4. Ëé∑Âèñuniqid
    private func getUniqid(from json: [String: Any]) -> String? {
        print("üîç Ëé∑Âèñuniqid...")
        
        guard let data = json["data"] as? [String: Any],
              let uniqid = data["uniqid"] as? String else {
            print("‚ùå Êó†Ê≥ïËé∑Âèñuniqid")
            return nil
        }
        
        return uniqid
    }
    
    // 4. Ëé∑ÂèñËß£ÂØÜÂ≠óÂÖ∏
    private func getDecryptionDictionary(uniqid: String, cookie: String) async -> String? {
        print("üîë Ëé∑ÂèñËß£ÂØÜÂ≠óÂÖ∏...")
        
        let urlString = "https://index.baidu.com/Interface/ptbk?uniqid=\(uniqid)"
        
        guard let url = URL(string: urlString) else {
            print("‚ùå Êó†ÊïàÁöÑËß£ÂØÜURL")
            return nil
        }
        
        var request = URLRequest(url: url)
        
        // ËÆæÁΩÆËØ∑Ê±ÇÂ§¥
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("application/json, text/plain, */*", forHTTPHeaderField: "Accept")
        request.setValue("Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36", forHTTPHeaderField: "User-Agent")
        request.setValue("same-origin", forHTTPHeaderField: "Sec-Fetch-Site")
        request.setValue("cors", forHTTPHeaderField: "Sec-Fetch-Mode")
        request.setValue("empty", forHTTPHeaderField: "Sec-Fetch-Dest")
        request.setValue("1698156005330_1698238860769_ZPrC2QTaXriysBT+5sgXcnbTX3/lW65av4zgu9uR1usPy82bArEg4m9deebXm7/O5g6QWhRxEd9/r/hqHad2WnVFVVWybHPFg3YZUUCKMTIYFeSUIn23C6HdTT1SI8mxsG5mhO4X9nnD6NGI8hF8L5/G+a5cxq+b21PADOpt/XB5eu/pWxNdwfa12krVNuYI1E8uHQ7TFIYjCzLX9MoJzPU6prjkgJtbi3v0X7WGKDJw9hwnd5Op4muW0vWKMuo7pbxUNfEW8wPRmSQjIgW0z5p7GjNpsg98rc3FtHpuhG5JFU0kZ6tHgU8+j6ekZW7+JljdyHUMwEoBOh131bGl+oIHR8vw8Ijtg8UXr0xZqcZbMEagEBzWiiKkEAfibCui59hltAgW5LG8IOtBDqp8RJkbK+IL5GcFkNaXaZfNMpI=", forHTTPHeaderField: "Cipher-Text")
        request.setValue("https://index.baidu.com/v2/main/index.html", forHTTPHeaderField: "Referer")
        request.setValue("zh-CN,zh;q=0.9", forHTTPHeaderField: "Accept-Language")
        request.setValue(cookie, forHTTPHeaderField: "Cookie")
        
        do {
            print("üîë Ëß£ÂØÜÂ≠óÂÖ∏URL: \(urlString)")
            
            let (data, response) = try await URLSession.shared.data(for: request)
            
            if let httpResponse = response as? HTTPURLResponse {
                print("üì° Ëß£ÂØÜËØ∑Ê±ÇÁä∂ÊÄÅÁ†Å: \(httpResponse.statusCode)")
                
                if httpResponse.statusCode != 200 {
                    print("‚ùå Ëß£ÂØÜËØ∑Ê±ÇÂ§±Ë¥•ÔºåÁä∂ÊÄÅÁ†Å: \(httpResponse.statusCode)")
                    return nil
                }
            }
            let responseString = String(data: data, encoding: .utf8) ?? ""
            print("üìÑ ÂìçÂ∫îÊï∞ÊçÆÈïøÂ∫¶: \(responseString.count) Â≠óÁ¨¶")
            print("üìÑ ÂìçÂ∫îÂÜÖÂÆπÈ¢ÑËßà: \(responseString)")
            
            // Ëß£ÊûêËß£ÂØÜÂìçÂ∫î
            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            
            guard let json = json,
                  let ptbk = json["data"] as? String else {
                print("‚ùå Êó†Ê≥ïËé∑ÂèñËß£ÂØÜÂ≠óÂÖ∏")
                return nil
            }
            
            return ptbk
            
        } catch {
            print("‚ùå Ëé∑ÂèñËß£ÂØÜÂ≠óÂÖ∏Â§±Ë¥•: \(error)")
            return nil
        }
    }
    
    // 5. Ëß£ÊûêÂØÜÊñá
    private func decryptData(ptbk: String, json: [String: Any]) -> [TrendData] {
        print("üîì Ëß£ÊûêÂØÜÊñá...")
        
        // Ëé∑ÂèñÂä†ÂØÜÁöÑÊåáÊï∞Êï∞ÊçÆ
        guard let data = json["data"] as? [String: Any],
              let userIndexes = data["userIndexes"] as? [[String: Any]] else {
            print("‚ùå Êó†Ê≥ïËé∑ÂèñÁî®Êà∑ÊåáÊï∞Êï∞ÊçÆ")
            return []
        }
        
        var trendData: [TrendData] = []
        
        for userIndex in userIndexes {
            // Ëé∑ÂèñÂÖ≥ÈîÆËØç‰ø°ÊÅØ
            guard let wordArray = userIndex["word"] as? [[String: Any]],
                  let firstWord = wordArray.first,
                  let wordName = firstWord["name"] as? String else {
                continue
            }
            
            print("üìä Ëß£ÊûêÂÖ≥ÈîÆËØç: \(wordName)")
            
            // Â§ÑÁêÜallÊï∞ÊçÆÔºàÊÄª‰ΩìÊï∞ÊçÆÔºâ
            if let allData = userIndex["all"] as? [String: Any],
               let encryptedData = allData["data"] as? String,
               let startDate = allData["startDate"] as? String,
               let endDate = allData["endDate"] as? String {
                
                print("üìà Ëß£ÊûêallÊï∞ÊçÆ: \(startDate) Âà∞ \(endDate)")
                let decryptedValues = decrypt(ptbk: ptbk, indexData: encryptedData)
                let dataPoints = parseDecryptedData(decryptedValues: decryptedValues, startDate: startDate, endDate: endDate, source: "\(source)-\(wordName)-all")
                trendData.append(contentsOf: dataPoints)
            }
        }
        
        return trendData
    }
    
    // Ëß£ÊûêËß£ÂØÜÂêéÁöÑÊï∞ÊçÆ
    private func parseDecryptedData(decryptedValues: String, startDate: String, endDate: String, source: String) -> [TrendData] {
        var trendData: [TrendData] = []
        
        // Ëß£ÊûêÊó•ÊúüËåÉÂõ¥
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        
        guard let start = dateFormatter.date(from: startDate),
              let end = dateFormatter.date(from: endDate) else {
            print("‚ùå Êó†Ê≥ïËß£ÊûêÊó•ÊúüËåÉÂõ¥")
            return []
        }
        
        // ËÆ°ÁÆóÂ§©Êï∞Â∑Æ
        let calendar = Calendar.current
        _ = calendar.dateComponents([.day], from: start, to: end).day ?? 0
        
        // ÂàÜÂâ≤Ëß£ÂØÜÂêéÁöÑÊï∞ÂÄº
        let values = decryptedValues.components(separatedBy: ",")
        
        for (index, valueStr) in values.enumerated() {
            guard let value = Double(valueStr.trimmingCharacters(in: .whitespaces)) else {
                continue
            }
            
            // ËÆ°ÁÆóÂØπÂ∫îÊó•Êúü
            let date = calendar.date(byAdding: .day, value: index, to: start) ?? start
            
            let trendDataPoint = TrendData(
                date: date,
                value: value,
                source: source
            )
            trendData.append(trendDataPoint)
            
            if index < 5 { // Âè™ÊâìÂç∞Ââç5‰∏™Êï∞ÊçÆÁÇπ
                print("üìä \(dateFormatter.string(from: date)): \(value)")
            }
        }
        
        return trendData
    }
    
    // Ëß£ÂØÜÂáΩÊï∞ÔºàÂØπÂ∫îPythonÁöÑdecryptÂáΩÊï∞Ôºâ
    private func decrypt(ptbk: String, indexData: String) -> String {
        let n = ptbk.count / 2
        let ptbkArray = Array(ptbk)
        
        // ÂàõÂª∫Êò†Â∞ÑÂ≠óÂÖ∏
        var mapping: [Character: Character] = [:]
        for i in 0..<n {
            mapping[ptbkArray[i]] = ptbkArray[i + n]
        }
        
        // Ëß£ÂØÜ
        let result = indexData.map { char in
            return mapping[char] ?? char
        }
        
        return String(result)
    }
    
    // ‰øùÂ≠òCookieÂà∞‰ª£Á†ÅÂêåÁõÆÂΩï‰∏ã
    static func saveCookie(_ cookie: String) {
        let currentFileURL = URL(fileURLWithPath: #file)
        let currentDirectory = currentFileURL.deletingLastPathComponent()
        let cookieFileURL = currentDirectory.appendingPathComponent("baidu_cookie.txt")
        
        do {
            try cookie.write(to: cookieFileURL, atomically: true, encoding: .utf8)
            print("‚úÖ CookieÂ∑≤‰øùÂ≠òÂà∞: \(cookieFileURL.path)")
        } catch {
            print("‚ùå ‰øùÂ≠òCookieÂ§±Ë¥•: \(error)")
        }
    }
    
    // ÊµãËØïÁà¨ÂèñÂäüËÉΩ
    static func testFetch() async {
        let fetcher = BaiduTrendsFetcher()
        let result = await fetcher.fetch()
        print("üß™ ÊµãËØïÁªìÊûú: Ëé∑ÂèñÂà∞ \(result.count) ‰∏™Êï∞ÊçÆÁÇπ")
        
        for (index, data) in result.prefix(3).enumerated() {
            print("Êï∞ÊçÆÁÇπ \(index + 1): \(data.date) - \(data.value)")
        }
    }
}

